// WAF Detection and Fingerprinting Module
// Based on response headers, behavior patterns, and timing analysis

export interface WAFDetectionResult {
  detected: boolean;
  wafType: string;
  confidence: number;
  evidence: string[];
  suggestedBypassTechniques: string[];
}

export interface WAFSignature {
  name: string;
  headers: { [key: string]: string | RegExp };
  statusCodes?: number[];
  bodyPatterns?: RegExp[];
  cookiePatterns?: RegExp[];
  responseTime?: {
    min?: number;
    max?: number;
  };
}

export class WAFDetector {
  private static readonly WAF_SIGNATURES: WAFSignature[] = [
    // Cloudflare
    {
      name: 'Cloudflare',
      headers: {
        'server': /cloudflare/i,
        'cf-ray': /^[a-f0-9]+-[A-Z]{3}$/,
        'cf-cache-status': /.*/,
        'cf-request-id': /.*/,
      },
      statusCodes: [403, 429],
      bodyPatterns: [
        /cloudflare/i,
        /attention required! \| cloudflare/i,
        /ray id: [a-f0-9]+-[A-Z]{3}/i,
      ],
    },

    // AWS WAF
    {
      name: 'AWS WAF',
      headers: {
        'server': /CloudFront/i,
        'x-amz-cf-id': /.*/,
        'x-amz-cf-pop': /.*/,
        'x-cache': /^(Hit|Miss) from cloudfront$/i,
      },
      statusCodes: [403],
      bodyPatterns: [
        /forbidden.*you don't have permission to access.*on this server/i,
        /request blocked/i,
      ],
    },

    // Imperva/Incapsula
    {
      name: 'Imperva',
      headers: {
        'x-iinfo': /.*/,
        'x-cdn': /Incapsula/i,
        'set-cookie': /incap_ses_|visid_incap_/i,
      },
      statusCodes: [403],
      bodyPatterns: [
        /incapsula/i,
        /request unsuccessful. incapsula incident id/i,
        /generated by cloudflare/i,
      ],
      cookiePatterns: [
        /incap_ses_\d+/,
        /visid_incap_\d+/,
      ],
    },

    // F5 BIG-IP
    {
      name: 'F5 BIG-IP',
      headers: {
        'server': /BIG-IP/i,
        'x-wa-info': /.*/,
        'f5-trace-id': /.*/,
      },
      statusCodes: [403],
      bodyPatterns: [
        /the requested url was rejected/i,
        /please consult with your administrator/i,
        /your support id is/i,
      ],
    },

    // ModSecurity
    {
      name: 'ModSecurity',
      headers: {
        'server': /mod_security|apache/i,
      },
      statusCodes: [403, 406],
      bodyPatterns: [
        /mod_security/i,
        /not acceptable/i,
        /apache.*forbidden/i,
        /request blocked by security policy/i,
      ],
    },

    // Akamai
    {
      name: 'Akamai',
      headers: {
        'server': /AkamaiGHost/i,
        'akamai-origin-hop': /.*/,
        'x-akamai-transformed': /.*/,
      },
      statusCodes: [403],
      bodyPatterns: [
        /access denied/i,
        /akamai/i,
        /reference #[0-9a-f]+/i,
      ],
    },

    // Barracuda
    {
      name: 'Barracuda',
      headers: {
        'server': /Barracuda/i,
        'x-barracuda-url': /.*/,
      },
      statusCodes: [403],
      bodyPatterns: [
        /barracuda/i,
        /access denied/i,
      ],
    },

    // Sucuri
    {
      name: 'Sucuri',
      headers: {
        'server': /Sucuri/i,
        'x-sucuri-id': /.*/,
        'x-sucuri-cache': /.*/,
      },
      statusCodes: [403],
      bodyPatterns: [
        /sucuri website firewall - access denied/i,
        /questions\? contact us at cloudproxy@sucuri\.net/i,
      ],
    },

    // Fastly
    {
      name: 'Fastly',
      headers: {
        'via': /fastly/i,
        'x-served-by': /cache-.*-fastly/i,
        'x-cache': /(HIT|MISS).*fastly/i,
      },
      statusCodes: [403],
    },

    // KeyCDN
    {
      name: 'KeyCDN',
      headers: {
        'server': /keycdn-engine/i,
        'x-edge-location': /.*/,
      },
      statusCodes: [403],
    },

    // StackPath (MaxCDN)
    {
      name: 'StackPath',
      headers: {
        'server': /NetDNA-cache|stackpath/i,
        'x-hw': /.*/,
      },
      statusCodes: [403],
    },

    // DenyAll
    {
      name: 'DenyAll',
      headers: {
        'server': /denyall/i,
      },
      statusCodes: [403],
      bodyPatterns: [
        /denyall/i,
      ],
    },

    // Fortinet FortiWeb
    {
      name: 'FortiWeb',
      headers: {
        'server': /Fortigate|FortiWeb/i,
      },
      statusCodes: [403],
      bodyPatterns: [
        /web filter violation/i,
        /fortigate/i,
      ],
    },

    // Wallarm
    {
      name: 'Wallarm',
      headers: {
        'server': /nginx-wallarm/i,
        'x-wallarm-instance': /.*/,
      },
      statusCodes: [403, 500],
    },

    // Radware AppWall
    {
      name: 'Radware',
      headers: {
        'server': /Radware|AppWall/i,
        'x-origin-requestid': /.*/,
      },
      statusCodes: [403],
    },

    // Varnish (often used with WAF modules)
    {
      name: 'Varnish',
      headers: {
        'server': /varnish/i,
        'x-varnish': /.*/,
        'via': /varnish/i,
      },
      statusCodes: [403],
    },

    // Generic detection patterns
    {
      name: 'Generic WAF',
      headers: {},
      statusCodes: [403, 406, 429],
      bodyPatterns: [
        /blocked|denied|forbidden|rejected|filtered/i,
        /security|firewall|protection/i,
        /malicious|suspicious|attack/i,
      ],
    },
  ];

  /**
   * Detect WAF from HTTP response
   */
  static async detectFromResponse(
    response: Response,
    responseBody?: string,
    responseTime?: number
  ): Promise<WAFDetectionResult> {
    const evidence: string[] = [];
    let bestMatch = {
      name: 'Unknown',
      confidence: 0,
      evidence: [] as string[],
    };

    for (const signature of this.WAF_SIGNATURES) {
      let confidence = 0;
      const matchEvidence: string[] = [];

      // Check headers
      for (const [headerName, pattern] of Object.entries(signature.headers)) {
        const headerValue = response.headers.get(headerName);
        if (headerValue) {
          if (typeof pattern === 'string') {
            if (headerValue.toLowerCase().includes(pattern.toLowerCase())) {
              confidence += 30;
              matchEvidence.push(`Header ${headerName}: ${headerValue}`);
            }
          } else if (pattern instanceof RegExp) {
            if (pattern.test(headerValue)) {
              confidence += 30;
              matchEvidence.push(`Header ${headerName}: ${headerValue} (matches ${pattern})`);
            }
          }
        }
      }

      // Check status codes
      if (signature.statusCodes && signature.statusCodes.includes(response.status)) {
        confidence += 20;
        matchEvidence.push(`Status code: ${response.status}`);
      }

      // Check response body patterns
      if (responseBody && signature.bodyPatterns) {
        for (const pattern of signature.bodyPatterns) {
          if (pattern.test(responseBody)) {
            confidence += 25;
            matchEvidence.push(`Body pattern match: ${pattern}`);
          }
        }
      }

      // Check cookie patterns
      if (signature.cookiePatterns) {
        const cookies = response.headers.get('set-cookie');
        if (cookies) {
          for (const pattern of signature.cookiePatterns) {
            if (pattern.test(cookies)) {
              confidence += 20;
              matchEvidence.push(`Cookie pattern match: ${pattern}`);
            }
          }
        }
      }

      // Check response time patterns
      if (responseTime && signature.responseTime) {
        const { min, max } = signature.responseTime;
        if ((min === undefined || responseTime >= min) &&
          (max === undefined || responseTime <= max)) {
          confidence += 10;
          matchEvidence.push(`Response time: ${responseTime}ms`);
        }
      }

      // Update best match
      if (confidence > bestMatch.confidence) {
        bestMatch = {
          name: signature.name,
          confidence,
          evidence: matchEvidence,
        };
      }
    }

    const detected = bestMatch.confidence > 20;
    const suggestedBypassTechniques = this.getSuggestedBypassTechniques(bestMatch.name);

    return {
      detected,
      wafType: detected ? bestMatch.name : 'Unknown',
      confidence: bestMatch.confidence,
      evidence: bestMatch.evidence,
      suggestedBypassTechniques,
    };
  }

  /**
   * Perform active WAF detection by sending probe requests
   */
  static async activeDetection(url: string): Promise<WAFDetectionResult> {
    const probePayloads = [
      "' OR '1'='1",
      '<script>alert(1)</script>',
      '../../../etc/passwd',
      'UNION SELECT 1,2,3--',
    ];

    const results: WAFDetectionResult[] = [];

    for (const payload of probePayloads) {
      try {
        const separator = url.includes('?') ? '&' : '?';
        const startTime = Date.now();
        const response = await fetch(`${url}${separator}test=${encodeURIComponent(payload)}`, {
          method: 'GET',
          redirect: 'manual',
        });
        const responseTime = Date.now() - startTime;
        const responseBody = await response.text();

        const detection = await this.detectFromResponse(response, responseBody, responseTime);
        if (detection.detected) {
          results.push(detection);
        }
      } catch (error) {
        console.error('Active detection probe failed:', error);
      }
    }

    // Return the detection result with highest confidence
    if (results.length > 0) {
      return results.reduce((best, current) =>
        current.confidence > best.confidence ? current : best
      );
    }

    return {
      detected: false,
      wafType: 'Unknown',
      confidence: 0,
      evidence: [],
      suggestedBypassTechniques: [],
    };
  }

  /**
   * Get suggested bypass techniques for detected WAF
   */
  private static getSuggestedBypassTechniques(wafType: string): string[] {
    const techniques: { [key: string]: string[] } = {
      'Cloudflare': [
        'Unicode encoding (\\u0027 instead of \')',
        'Double URL encoding (%2527 instead of %27)',
        'Mixed case keywords (uNiOn instead of UNION)',
        'Alternative space characters (\\u00A0)',
        'Comment-based obfuscation (/**/)',
      ],
      'AWS WAF': [
        'Unicode normalization bypasses',
        'Character set encoding variations',
        'Request method variations',
        'Content-Type manipulation',
      ],
      'Imperva': [
        'Parameter pollution',
        'HTTP verb tampering',
        'Custom header injection',
        'Encoding combinations',
      ],
      'F5 BIG-IP': [
        'Request smuggling techniques',
        'HTTP/1.0 downgrade',
        'Custom User-Agent strings',
      ],
      'ModSecurity': [
        'Comment-based SQL obfuscation',
        'Case sensitivity exploits',
        'Regex pattern bypasses',
        'Alternative operators',
      ],
      'Akamai': [
        'IP-based bypasses',
        'Origin server direct access',
        'Cache poisoning techniques',
      ],
      'Generic WAF': [
        'Double URL encoding',
        'Unicode encoding',
        'Mixed case obfuscation',
        'Comment insertion',
        'Parameter pollution',
        'HTTP verb tampering',
      ],
    };

    return techniques[wafType] || techniques['Generic WAF'];
  }

  /**
   * Detect WAF bypass opportunities
   */
  static async detectBypassOpportunities(url: string): Promise<{
    httpMethodsBypass: boolean;
    headerBypass: boolean;
    encodingBypass: boolean;
    parameterPollution: boolean;
  }> {
    const opportunities = {
      httpMethodsBypass: false,
      headerBypass: false,
      encodingBypass: false,
      parameterPollution: false,
    };

    try {
      // Test HTTP method bypass
      const methodResponse = await fetch(url, { method: 'TRACE', redirect: 'manual' });
      if (methodResponse.status !== 405) {
        opportunities.httpMethodsBypass = true;
      }

      // Test header bypass with X-Original-URL
      const headerResponse = await fetch(url, {
        method: 'GET',
        headers: { 'X-Original-URL': '/admin' },
        redirect: 'manual',
      });
      if (headerResponse.status === 200) {
        opportunities.headerBypass = true;
      }

      // Test encoding bypass
      const encodedPayload = '%2527%2520OR%25201%253D1';
      const encodingSeparator = url.includes('?') ? '&' : '?';
      const encodingResponse = await fetch(`${url}${encodingSeparator}test=${encodedPayload}`, {
        method: 'GET',
        redirect: 'manual',
      });
      if (encodingResponse.status === 200) {
        opportunities.encodingBypass = true;
      }

      // Test parameter pollution
      const pollutionSeparator = url.includes('?') ? '&' : '?';
      const pollutionResponse = await fetch(`${url}${pollutionSeparator}test=safe&test=malicious`, {
        method: 'GET',
        redirect: 'manual',
      });
      if (pollutionResponse.status === 200) {
        opportunities.parameterPollution = true;
      }
    } catch (error) {
      console.error('Bypass opportunity detection failed:', error);
    }

    return opportunities;
  }
}
